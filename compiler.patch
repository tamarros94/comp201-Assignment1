diff --git a/.directory b/.directory
new file mode 100644
index 0000000..1dca8fd
--- /dev/null
+++ b/.directory
@@ -0,0 +1,6 @@
+[Dolphin]
+Timestamp=2019,11,27,15,50,11
+Version=4
+
+[Settings]
+HiddenFilesShown=true
diff --git a/pc.ml b/pc.ml
index 6a25660..8c761a5 100644
--- a/pc.ml
+++ b/pc.ml
@@ -1,189 +1,242 @@
-(* pc.ml
- * A parsing-combinators package for ocaml
- *
- * Prorammer: Mayer Goldberg, 2018
- *)
-
-(* general list-processing procedures *)
-
-let rec ormap f s =
-  match s with
-  | [] -> false
-  | car :: cdr -> (f car) || (ormap f cdr);;
-
-let rec andmap f s =
-  match s with
-  | [] -> true
-  | car :: cdr -> (f car) && (andmap f cdr);;	  
-
-let lowercase_ascii  =
-  let delta = int_of_char 'A' - int_of_char 'a' in
-  fun ch ->
-  if ('A' <= ch && ch <= 'Z')
-  then char_of_int ((int_of_char ch) - delta)
-  else ch;;
-
-let string_to_list str =
-  let rec loop i limit =
-    if i = limit then []
-    else (String.get str i) :: (loop (i + 1) limit)
-  in
-  loop 0 (String.length str);;
-
-let list_to_string s =
-  String.concat "" (List.map (fun ch -> String.make 1 ch) s);;
-
-module PC = struct
-
-(* the parsing combinators defined here *)
-  
-exception X_not_yet_implemented;;
-
-exception X_no_match;;
-
-let const pred =
-  function 
-  | [] -> raise X_no_match
-  | e :: s ->
-     if (pred e) then (e, s)
-     else raise X_no_match;;
-
-let caten nt1 nt2 s =
-  let (e1, s) = (nt1 s) in
-  let (e2, s) = (nt2 s) in
-  ((e1, e2), s);;
-
-let pack nt f s =
-  let (e, s) = (nt s) in
-  ((f e), s);;
-
-let nt_epsilon s = ([], s);;
-
-let caten_list nts =
-  List.fold_right
-    (fun nt1 nt2 ->
-     pack (caten nt1 nt2)
-	  (fun (e, es) -> (e :: es)))
-    nts
-    nt_epsilon;;
-
-let disj nt1 nt2 =
-  fun s ->
-  try (nt1 s)
-  with X_no_match -> (nt2 s);;
-
-let nt_none _ = raise X_no_match;;
-  
-let disj_list nts = List.fold_right disj nts nt_none;;
-
-let delayed thunk s =
-  thunk() s;;
-
-let nt_end_of_input = function
-  | []  -> ([], [])
-  | _ -> raise X_no_match;;
-
-let rec star nt s =
-  try let (e, s) = (nt s) in
-      let (es, s) = (star nt s) in
-      (e :: es, s)
-  with X_no_match -> ([], s);;
-
-let plus nt =
-  pack (caten nt (star nt))
-       (fun (e, es) -> (e :: es));;
-
-let guard nt pred s =
-  let ((e, _) as result) = (nt s) in
-  if (pred e) then result
-  else raise X_no_match;;
-  
-let diff nt1 nt2 s =
-  match (let result = nt1 s in
-	 try let _ = nt2 s in
-	     None
-	 with X_no_match -> Some(result)) with
-  | None -> raise X_no_match
-  | Some(result) -> result;;
-
-let not_followed_by nt1 nt2 s =
-  match (let ((_, s) as result) = (nt1 s) in
-	 try let _ = (nt2 s) in
-	     None
-	 with X_no_match -> (Some(result))) with
-  | None -> raise X_no_match
-  | Some(result) -> result;;
-	  
-let maybe nt s =
-  try let (e, s) = (nt s) in
-      (Some(e), s)
-  with X_no_match -> (None, s);;
-
-(* useful general parsers for working with text *)
-
-let make_char equal ch1 = const (fun ch2 -> equal ch1 ch2);;
-
-let char = make_char (fun ch1 ch2 -> ch1 = ch2);;
-
-let char_ci =
-  make_char (fun ch1 ch2 ->
-	     (lowercase_ascii ch1) =
-	       (lowercase_ascii ch2));;
-
-let make_word char str = 
-  List.fold_right
-    (fun nt1 nt2 -> pack (caten nt1 nt2) (fun (a, b) -> a :: b))
-    (List.map char (string_to_list str))
-    nt_epsilon;;
-
-let word = make_word char;;
-
-let word_ci = make_word char_ci;;
-
-let make_one_of char str =
-  List.fold_right
-    disj
-    (List.map char (string_to_list str))
-    nt_none;;
-
-let one_of = make_one_of char;;
-
-let one_of_ci = make_one_of char_ci;;
-
-let nt_whitespace = const (fun ch -> ch <= ' ');;
-
-let make_range leq ch1 ch2 (s : char list) =
-  const (fun ch -> (leq ch1 ch) && (leq ch ch2)) s;;
-
-let range = make_range (fun ch1 ch2 -> ch1 <= ch2);;
-
-let range_ci =
-  make_range (fun ch1 ch2 ->
-	      (lowercase_ascii ch1) <=
-		(lowercase_ascii ch2));;
-
-let nt_any (s : char list) = const (fun ch -> true) s;;
-
-let trace_pc desc nt s =
-  try let ((e, s') as args) = (nt s)
-      in
-      (Printf.printf ";;; %s matched the head of \"%s\", and the remaining string is \"%s\"\n"
-		     desc
-		     (list_to_string s)
-		     (list_to_string s') ;
-       args)
-  with X_no_match ->
-    (Printf.printf ";;; %s failed on \"%s\"\n"
-		   desc
-		   (list_to_string s) ;
-     raise X_no_match);;
-
-(* testing the parsers *)
-
-let test_string nt str =
-  let (e, s) = (nt (string_to_list str)) in
-  (e, (Printf.sprintf "->[%s]" (list_to_string s)));;
-
-end;; (* end of struct PC *)
-
-(* end-of-input *)
+(* pc.ml
+ * A parsing-combinators package for ocaml
+ *
+ * Prorammer: Mayer Goldberg, 2018
+ *)
+
+(* general list-processing procedures *)
+
+(* applies boolean function to every element in list and return true if at least one element is true*)
+let rec ormap f s =
+  match s with
+  | [] -> false
+  | car :: cdr -> (f car) || (ormap f cdr);;
+
+(* applies boolean function to every element in list and return false if at least one element is false*)
+let rec andmap f s =
+  match s with
+  | [] -> true
+  | car :: cdr -> (f car) && (andmap f cdr);;	 
+
+(* turn uppercase char to lowercase *)
+let lowercase_ascii  =
+  let delta = int_of_char 'A' - int_of_char 'a' in
+  fun ch ->
+  if ('A' <= ch && ch <= 'Z')
+  then char_of_int ((int_of_char ch) - delta)
+  else ch;;
+
+(* turns string to list of chars*)
+let string_to_list str =
+  let rec loop i limit =
+    if i = limit then []
+    else (String.get str i) :: (loop (i + 1) limit)
+  in
+  loop 0 (String.length str);;
+
+(* turns list to string*)
+let list_to_string s =
+  String.concat "" (List.map (fun ch -> String.make 1 ch) s);;
+
+module PC = struct
+
+(* the parsing combinators defined here *)
+  
+exception X_not_yet_implemented;;
+
+exception X_no_match;;
+
+(* The const PC takes a predicate (char -> bool), and return a
+parser that recognizes this character *)
+let const pred =
+  function 
+  | [] -> raise X_no_match
+  | e :: s ->
+     if (pred e) then (e, s)
+     else raise X_no_match;;
+
+(* We try to parse the head of s using nt1
+▶ If we succeed, we get e1 and the remaining chars s
+▶ We try to parse the head of s (what remained after nt1) using nt2
+▶ If we succeed, we get e2 and the remaining chars s
+▶ We return the pair of e1 & e2, as well as the remaining chars *)
+let caten nt1 nt2 s =
+  let (e1, s) = (nt1 s) in
+  let (e2, s) = (nt2 s) in
+  ((e1, e2), s);;
+
+(* pack takes a non-terminal nt and a function f
+▶ returns a parser that recognizes the same language as nt
+▶ …but which applies f to whatever was matched *)
+let pack nt f s =
+  let (e, s) = (nt s) in
+  ((f e), s);;
+
+(* parser that recognizes ε-productions
+This is like I (evar hayehida) -> caten nt nt_epsilon = caten nt_epsilon nt = nt *)
+let nt_epsilon s = ([], s);;
+
+(* given a list of non-terminals:
+    returns function that receives list s and:
+      for each pair of non terminals in list s: performs caten and concatenates result list until nt_epsilon
+     *)
+let caten_list nts =
+  List.fold_right
+    (fun nt1 nt2 ->
+     pack (caten nt1 nt2)
+	  (fun (e, es) -> (e :: es)))
+    nts
+    nt_epsilon;;
+
+(* We try to parse the head of s using nt1
+▶ If we succeed, then the call to nt1 returns normally
+▶ If we fail we try to parse the head of s using nt2 *)
+let disj nt1 nt2 =
+  fun s ->
+  try (nt1 s)
+  with X_no_match -> (nt2 s);;
+
+(*parser that always fails
+disj nt nt_none ≡ disj nt_none nt ≡ nt*)
+let nt_none _ = raise X_no_match;;
+
+(* given a list of non-terminals:
+    returns function that receives list s and:
+      for each pair of non terminals in list: performs disj on s until nt_none
+     *)
+let disj_list nts = List.fold_right disj nts nt_none;;
+
+(* kind of like lazy-eval: supposed to handle recursive CFG like A->A|B
+To implement recursive parsers, we need to delay the evaluation of the recursive non-terminal
+▶ A thunk is a procedure that takes zero arguments
+▶ Thunks are used to delay evaluation*)
+let delayed thunk s =
+  thunk() s;;
+
+(*parser that recognizes the end of the
+input stream (and fails otherwise)*)
+let nt_end_of_input = function
+  | []  -> ([], [])
+  | _ -> raise X_no_match;;
+
+(* applies nt on every element on the list s until there's no match*)
+let rec star nt s =
+  try let (e, s) = (nt s) in
+      let (es, s) = (star nt s) in
+      (e :: es, s)
+  with X_no_match -> ([], s);;
+
+(* given a non-terminal -> 
+    returns a function that receives a list:
+      (at least one)production result concatenated to all production rules possibilities contcatinated*)
+let plus nt =
+  pack (caten nt (star nt))
+       (fun (e, es) -> (e :: es));;
+
+(* We might want to attach an arbitrary predicate to serve as a guard
+for a parser, so that the parser succeeds only if the matched object
+satisfies the guard.*)
+let guard nt pred s =
+  let ((e, _) as result) = (nt s) in
+  if (pred e) then result
+  else raise X_no_match;;
+  
+  (* applies nt1 on s and then nt2 on the same s.
+  Scenarios:
+    1. nt1 raises X_no_match -> diff raises throws X_no_match
+    2. nt1 passes + nt2 throws X_no_match -> 1st part is matched with 'Some' and result is returned
+    3. nt1 passes + nt2 passes -> 1st part is matched with 'None' and diff raises X_no_match 
+  returns a parser that accepts the language of nt1 WITHOUT the language of nt2
+  e.g: I want nt_no_digits then I can run diff nt_all nt_digits*)
+let diff nt1 nt2 s =
+  match (let result = nt1 s in
+	 try let _ = nt2 s in
+	     None
+	 with X_no_match -> Some(result)) with
+  | None -> raise X_no_match
+  | Some(result) -> result;;
+
+(* applies nt1 on s and then applies nt2 on s' leftover of nt1. 
+  e.g: *)
+let not_followed_by nt1 nt2 s =
+  match (let ((_, s) as result) = (nt1 s) in
+	 try let _ = (nt2 s) in
+	     None
+	 with X_no_match -> (Some(result))) with
+  | None -> raise X_no_match
+  | Some(result) -> result;;
+	  
+(*applies nt on s, if there's no match, (None,s) is returned instead of raising error, and (Some(e), s) otherwise*)
+let maybe nt s =
+  try let (e, s) = (nt s) in
+      (Some(e), s)
+  with X_no_match -> (None, s);;
+
+(* useful general parsers for working with text *)
+
+let make_char equal ch1 = const (fun ch2 -> equal ch1 ch2);;
+
+let char = make_char (fun ch1 ch2 -> ch1 = ch2);;
+
+let char_ci =
+  make_char (fun ch1 ch2 ->
+	     (lowercase_ascii ch1) =
+	       (lowercase_ascii ch2));;
+
+let make_word char str = 
+  List.fold_right
+    (fun nt1 nt2 -> pack (caten nt1 nt2) (fun (a, b) -> a :: b))
+    (List.map char (string_to_list str))
+    nt_epsilon;;
+
+let word = make_word char;;
+
+let word_ci = make_word char_ci;;
+
+let make_one_of char str =
+  List.fold_right
+    disj
+    (List.map char (string_to_list str))
+    nt_none;;
+
+let one_of = make_one_of char;;
+
+let one_of_ci = make_one_of char_ci;;
+
+let nt_whitespace = const (fun ch -> ch <= ' ');;
+
+let make_range leq ch1 ch2 (s : char list) =
+  const (fun ch -> (leq ch1 ch) && (leq ch ch2)) s;;
+
+let range = make_range (fun ch1 ch2 -> ch1 <= ch2);;
+
+let range_ci =
+  make_range (fun ch1 ch2 ->
+	      (lowercase_ascii ch1) <=
+		(lowercase_ascii ch2));;
+
+let nt_any (s : char list) = const (fun ch -> true) s;;
+
+let trace_pc desc nt s =
+  try let ((e, s') as args) = (nt s)
+      in
+      (Printf.printf ";;; %s matched the head of \"%s\", and the remaining string is \"%s\"\n"
+		     desc
+		     (list_to_string s)
+		     (list_to_string s') ;
+       args)
+  with X_no_match ->
+    (Printf.printf ";;; %s failed on \"%s\"\n"
+		   desc
+		   (list_to_string s) ;
+     raise X_no_match);;
+
+(* testing the parsers *)
+
+let test_string nt str =
+  let (e, s) = (nt (string_to_list str)) in
+  (e, (Printf.sprintf "->[%s]" (list_to_string s)));;
+
+end;; (* end of struct PC *)
+
+(* end-of-input *)
diff --git a/reader.ml b/reader.ml
index c4fd6b2..fb9e97e 100644
--- a/reader.ml
+++ b/reader.ml
@@ -1,52 +1,385 @@
-
-#use "pc.ml";;
-
-exception X_not_yet_implemented;;
-exception X_this_should_not_happen;;
-  
-type number =
-  | Int of int
-  | Float of float;;
-  
-type sexpr =
-  | Bool of bool
-  | Nil
-  | Number of number
-  | Char of char
-  | String of string
-  | Symbol of string
-  | Pair of sexpr * sexpr
-  | TaggedSexpr of string * sexpr
-  | TagRef of string;;
-
-let rec sexpr_eq s1 s2 =
-  match s1, s2 with
-  | Bool(b1), Bool(b2) -> b1 = b2
-  | Nil, Nil -> true
-  | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
-  | Number(Int n1), Number(Int n2) -> n1 = n2
-  | Char(c1), Char(c2) -> c1 = c2
-  | String(s1), String(s2) -> s1 = s2
-  | Symbol(s1), Symbol(s2) -> s1 = s2
-  | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
-  | TaggedSexpr(name1, expr1), TaggedSexpr(name2, expr2) -> (name1 = name2) && (sexpr_eq expr1 expr2) 
-  | TagRef(name1), TagRef(name2) -> name1 = name2
-  | _ -> false;;
-  
-module Reader: sig
-  val read_sexpr : string -> sexpr
-  val read_sexprs : string -> sexpr list
-end
-= struct
-let normalize_scheme_symbol str =
-  let s = string_to_list str in
-  if (andmap
-	(fun ch -> (ch = (lowercase_ascii ch)))
-	s) then str
-  else Printf.sprintf "|%s|" str;;
-
-let read_sexpr string = raise X_not_yet_implemented ;;
-
-let read_sexprs string = raise X_not_yet_implemented;;
-  
-end;; (* struct Reader *)
+#use "pc.ml";;
+open PC;;
+
+exception X_not_yet_implemented;;
+exception X_this_should_not_happen;;
+  
+type number =
+  | Int of int
+  | Float of float;;
+  
+type sexpr =
+  | Bool of bool
+  | Nil
+  | Number of number
+  | Char of char
+  | String of string
+  | Symbol of string
+  | Pair of sexpr * sexpr
+  | TaggedSexpr of string * sexpr
+  | TagRef of string;;
+
+let rec sexpr_eq s1 s2 =
+  match s1, s2 with
+  | Bool(b1), Bool(b2) -> b1 = b2
+  | Nil, Nil -> true
+  | Number(Float f1), Number(Float f2) -> abs_float(f1 -. f2) < 0.001
+  | Number(Int n1), Number(Int n2) -> n1 = n2
+  | Char(c1), Char(c2) -> c1 = c2
+  | String(s1), String(s2) -> s1 = s2
+  | Symbol(s1), Symbol(s2) -> s1 = s2
+  | Pair(car1, cdr1), Pair(car2, cdr2) -> (sexpr_eq car1 car2) && (sexpr_eq cdr1 cdr2)
+  | TaggedSexpr(name1, expr1), TaggedSexpr(name2, expr2) -> (name1 = name2) && (sexpr_eq expr1 expr2) 
+  | TagRef(name1), TagRef(name2) -> name1 = name2
+  | _ -> false;;
+  
+module Reader : sig
+  val read_sexpr : string -> sexpr
+  val read_sexprs : string -> sexpr list
+end
+= struct
+let normalize_scheme_symbol str =
+  let s = string_to_list str in
+  if (andmap
+	(fun ch -> (ch = (lowercase_ascii ch)))
+	s) then str
+  else Printf.sprintf "|%s|" str;;
+  
+(*abstract parsers*)
+(* abstract parser that skips nt_right and nt_left results from left and right of nt *)
+let make_paired nt_left nt_right nt =
+  let nt = caten nt_left nt in
+  let nt = pack nt (function (_, e) -> e) in
+  let nt = caten nt nt_right in
+  let nt = pack nt (function (e, _) -> e) in
+  nt;;
+
+(* 3.2.1 Whitespaces *)
+let nt_whitespace = const (fun ch -> ch <= ' ');;
+(* parser that skips whitesapes from left and right of nt *)
+let make_spaced nt = make_paired (star nt_whitespace) (star nt_whitespace) nt;;
+
+(* 3.2.2 Line comments *)
+let nt_comment_line = 
+    let nt_semicolon = char ';' in
+    let nt_eol = char (char_of_int 10) in
+    let nt_all_but_eol = diff nt_any nt_eol in
+    let nt_end_of_comment = disj nt_eol (pack nt_end_of_input (fun (dummy) -> 'd')) in
+    let nt = caten nt_semicolon (star nt_all_but_eol) in
+    let nt = caten nt nt_end_of_comment in
+    let nt = pack nt (fun e -> Nil) in
+    make_spaced nt;;
+    
+
+(*3.3.1 Boolean*)
+let nt_boolean =
+    let nt_hashtag = char '#' in
+    let nt_f = word_ci "f" in
+    let nt_t = word_ci "t" in
+    let nt_false = pack nt_f (fun f -> false) in
+    let nt_true = pack nt_t (fun t -> true) in
+    let nt = disj nt_false nt_true in
+    let nt = caten nt_hashtag nt in
+    (* let nt = pack nt (function (_, false) -> (Bool false)) in  *)
+    let nt = pack nt (function (_0x, e) -> (Bool e)) in
+nt;;
+
+(*3.3.3 Symbol*)
+let digit = range '0' '9';;
+
+let nt_symbol =
+    let lowercase_letters = range 'a' 'z' in
+    let uppercase_letters = range 'A' 'Z' in
+    let punctuation = disj_list [char ':';char '!'; char '$'; char '^'; char '*'; char '-'; char '_'; char '='; char '+'; char '<'; char '>'; char '/'; char '?'] in    
+    let norm_uppercase = pack uppercase_letters lowercase_ascii in
+    let nt = disj_list [lowercase_letters; norm_uppercase; punctuation; digit] in
+    let nt = plus nt in
+    let nt = pack nt (fun e -> let str = list_to_string e in Symbol(str)) in
+    nt;;
+
+(*3.3.2 Number*)
+let not_digit = const (fun ch -> ch < '0' || ch > '9');;
+
+(*int*)
+let nt_int = 
+    let nt_body = pack (not_followed_by (plus digit) (char '.')) (function e -> int_of_string ((list_to_string e))) in
+    let nt_plus_op = char '+' in
+    let nt_minus_op = char '-' in
+    let nt_op = disj nt_minus_op nt_plus_op in
+    let nt_signed = pack (caten nt_op nt_body) 
+    (function (op,num) -> if (op = '-') then (-1)*(num) else num) in
+    let nt = disj nt_signed nt_body in
+    nt;;
+
+
+let nt_int_packed = 
+    let nt = not_followed_by nt_int nt_symbol in
+    pack nt (fun e -> Int(e));;
+ 
+(*float*)
+let nt_float =
+    let nt_dot = char '.' in
+    let nt_form = caten (plus digit) (caten nt_dot (plus digit)) in
+    let nt_body = pack nt_form 
+    (function (a,(b, c)) -> float_of_string ((list_to_string a) ^ "." ^ (list_to_string c))) in
+    let nt_plus_op = char '+' in
+    let nt_minus_op = char '-' in
+    let nt_op = disj nt_minus_op nt_plus_op in
+    let nt_signed = pack (caten nt_op nt_body) 
+    (function (op,num) -> if (op = '-') then (-1.0)*.(num) else num) in
+    let nt = disj nt_signed nt_body in
+    nt;;
+    (*number*)
+
+let nt_float_packed = 
+    let nt_symbols_not_e = diff nt_symbol (word_ci "e") in
+    let nt = not_followed_by nt_float nt_symbols_not_e in
+    pack nt (fun e -> Float(e));;
+    
+    (*number*)
+
+(*4.1 Scientific notation*)
+let nt_scientific_notation = 
+    let nt_int_to_float = pack nt_int (fun e -> float_of_int e) in
+    let nt = disj nt_int_to_float nt_float in
+    let nt_e = word_ci "e" in
+    let nt = caten nt (caten nt_e nt_int_to_float) in
+    (* let nt = not_followed_by nt nt_symbol in *)
+    let nt = pack nt (fun (num, (e, exp)) -> let n = num *. (10. ** exp) in Float(n)) in
+    nt;;
+
+
+let make_nt_digit ch_from ch_to displacement =
+    let nt = const (fun ch -> ch_from <= ch && ch <= ch_to) in
+    let nt = pack nt (let delta = (Char.code ch_from) - displacement in
+		      fun ch -> (Char.code ch) - delta) in
+    nt;;
+
+let nt_radix_cal radix =
+  let nt = disj (make_nt_digit '0' '9' 0)
+		(make_nt_digit 'a' 'z' 10) in
+  let nt = disj nt (make_nt_digit 'A' 'Z' 10) in
+  let nt = plus nt in
+  let nt = pack nt (fun digits ->
+		    List.fold_left (fun a b -> radix * a + b) 0 digits) in
+  nt;;
+
+let nt_radix_cal_float radix =
+  let nt = disj (make_nt_digit '0' '9' 0)
+		(make_nt_digit 'a' 'z' 10) in
+  let nt = disj nt (make_nt_digit 'A' 'Z' 10) in
+  let nt = pack nt (fun e -> float_of_int e) in
+  let nt = plus nt in
+  (* let nt = pack nt (fun digits -> (1./.(float_of_int radix))) in   *)
+  let nt = pack nt (fun digits -> List.fold_right (fun a b -> (1./.(float_of_int radix)) *. (b +. a)) digits 0.) in  
+  nt;;
+
+let nt_radix_range = disj_list [digit; range 'a' 'z'; range 'A' 'Z'] ;;
+
+let nt_radix_identifier = 
+    let nt_hashtag = char '#' in
+    let nt_r = disj (char 'r') (char 'R') in
+    let body_until_r = caten nt_hashtag (caten nt_int nt_r) in
+
+    let nt_plus_op = char '+' in
+    let nt_minus_op = char '-' in
+    let nt_op = disj nt_minus_op nt_plus_op in
+    let nt_signed = caten body_until_r nt_op in 
+    let nt_signed = pack nt_signed (fun ((_hash, (base,r)), op) -> (op,(_hash, (base,r)))) in
+
+    let nt = disj nt_signed (pack body_until_r (fun (_hash, (base,r)) -> ('+',(_hash, (base,r))))) in
+    let nt = pack nt (fun (op, (_hash, (base,_r))) -> (op, base)) in
+    nt;;
+
+let nt_int_radix = 
+    let nt = not_followed_by (plus nt_radix_range) (char '.') in
+    let nt = caten nt_radix_identifier nt in
+    let nt = pack nt (fun ((op,base), num) -> (op, (nt_radix_cal base num))) in
+    let nt = pack nt (fun (op, (num,_)) -> if (op = '-') then (-1)*(num) else num) in
+    let nt = pack nt (fun (num) -> Int(num)) in
+    nt;;
+
+let nt_float_radix = 
+    let nt_form = caten (plus nt_radix_range) (caten (char '.') (plus nt_radix_range)) in
+    let nt = pack nt_form (fun (a, (_, b)) -> (a,b)) in
+    let nt = caten nt_radix_identifier nt in
+    let nt = pack nt (fun ((op,base), (left, right)) -> 
+    let converted_left = nt_radix_cal base left  in
+    let converted_right = nt_radix_cal_float base right in
+    (op,(converted_left, converted_right))) in
+    let nt = pack nt (fun (op,((e1,_),(e2,_))) -> 
+        let converted = (float_of_int e1) +. e2 in
+        (op, converted)) in
+    let nt = pack nt (fun (op, num) -> if (op = '-') then (-1.)*.(num) else num) in
+    let nt = pack nt (fun num -> Float(num)) in
+    nt;;
+
+let nt_number = 
+    let nt = disj_list [nt_float_radix;nt_int_radix;nt_scientific_notation;nt_float_packed; nt_int_packed] in
+    let nt = pack nt (function e -> Number(e)) in
+    nt;;
+
+(*3.3.4 String*)
+let nt_string = 
+    let string_literal_char = diff nt_any (disj (char (char_of_int 34)) (char (char_of_int 92))) in
+    let string_meta_char = disj_list [
+        pack (word "\\\\") (fun e -> char_of_int 92);
+        pack (word "\\\"") (fun e -> char_of_int 34);
+        pack (word "\\t") (fun e -> char_of_int 9);
+        pack (word "\\f") (fun e -> char_of_int 12);
+        pack (word "\\n") (fun e -> char_of_int 10);
+        pack (word "\\r") (fun e -> char_of_int 13)
+        ] in
+    let nt_body = disj string_literal_char string_meta_char in
+    let nt_double_quote = char (char_of_int (34)) in
+    let nt = caten nt_double_quote (caten (star nt_body) nt_double_quote) in
+    let nt = pack nt (fun (_, (e, _)) -> String(list_to_string e)) in
+    nt;;
+
+(*3.3.5 Char*)
+let nt_char =
+    let char_prefix = word "#\\" in
+    let visible_simple_char = const (fun ch -> (int_of_char ch) > 32) in
+    let named_char = disj_list [
+        pack (word "nul") (fun e -> char_of_int 0);
+        pack (word "newline") (fun e -> char_of_int 10);
+        pack (word "return") (fun e -> char_of_int 13);
+        pack (word "tab") (fun e -> char_of_int 9);
+        pack (word "page") (fun e -> char_of_int 12);
+        pack (word "space") (fun e -> char_of_int 32)
+        ] in
+    let nt = disj visible_simple_char named_char in
+    let nt = pack (caten char_prefix nt) (fun (_, e) -> Char(e)) in
+    nt;;
+
+(*3.3.6 Nil*)
+let nt_nil = 
+    let prefix = char '(' in
+    let postfix = char ')' in
+    let body = disj nt_comment_line (pack nt_whitespace (fun e -> Nil)) in
+    let nt = caten prefix (caten (star body) postfix) in
+    let nt = pack nt (fun e -> Nil) in
+    nt;;
+
+
+let nt_teg_ref_identifier= 
+    let prefix = word "#{" in
+    let postfix = word "}" in
+    let symbol_name = pack nt_symbol (
+        function e -> match e with
+        | Symbol(name) -> name
+        | other_sexpr -> raise X_no_match ) in
+    let nt = caten prefix (caten (symbol_name) postfix) in
+    let nt = pack nt (fun (_, (name, _)) -> name) in
+    nt;;
+
+(* sexp *)
+
+let rec nt_sexpr str = 
+    let sexpr_disj = disj_list [
+            nt_boolean;
+            nt_char;
+            nt_number;
+            nt_string;
+            nt_symbol;
+            nt_list;
+            nt_dotted_list;
+            nt_quote;
+            nt_quasi_quote;
+            nt_unquote;
+            nt_unquote_and_splice;
+            nt_tagged_sexpr;
+            nt_tag_ref
+           ] in
+    (make_spaced_or_commented sexpr_disj) str
+    and nt_list s = 
+        let prefix = char '(' in
+        let postfix = char ')' in
+        let body = star nt_sexpr in
+        let nt = caten prefix (caten body postfix) in
+        pack nt (
+            function (_,(e,_)) -> match e with
+            |[] -> Nil
+            |lst -> List.fold_right (fun sexpr1 sexpr2 -> Pair(sexpr1, sexpr2)) lst Nil
+        ) s
+    and nt_dotted_list s = 
+        let prefix = char '(' in
+        let postfix = char ')' in
+        let nt_dot = char '.' in
+        let body = caten (plus nt_sexpr) (caten nt_dot nt_sexpr) in
+        let nt = caten prefix (caten body postfix) in
+        pack nt (
+            function (_,(e,_)) -> match e with
+            |(a, (_, b)) -> List.fold_right (fun sexpr1 sexpr2 -> Pair(sexpr1, sexpr2)) a b
+        ) s
+    and nt_quote s = 
+        let prefix = word "'" in
+        let nt = caten prefix nt_sexpr in
+        pack nt (function (_, e) -> Pair(Symbol("quote"), Pair(e, Nil)))
+        s
+    and nt_quasi_quote s = 
+        let prefix = word "`" in
+        let nt = caten prefix nt_sexpr in
+        pack nt (function (_, e) -> Pair(Symbol("quasiquote"), Pair(e, Nil)))
+        s
+    and nt_unquote s = 
+        let prefix = word "," in
+        let nt = caten prefix nt_sexpr in
+        pack nt (function (_, e) -> Pair(Symbol("unquote"), Pair(e, Nil)))
+        s
+    and nt_unquote_and_splice s = 
+        let prefix = word ",@" in
+        let nt = caten prefix nt_sexpr in
+        pack nt (function (_, e) -> Pair(Symbol("unquote-splicing"), Pair(e, Nil)))
+        s
+    and nt_tag_ref s =
+        let nt = pack nt_teg_ref_identifier (fun name -> TagRef(name)) in
+        nt s
+    and nt_tagged_sexpr s =
+        let eq_sign = word "=" in
+        let nt = caten nt_teg_ref_identifier eq_sign in
+        let nt = caten nt nt_sexpr in
+        let nt = pack nt (fun ((name,_),sexpr) -> TaggedSexpr(name, sexpr)) in
+        let nt = pack nt (fun e -> 
+            let rec check_if_valid original_name rec_sexpr = match rec_sexpr with
+                |TaggedSexpr(some_name, some_sexpr) -> 
+                    if some_name = original_name 
+                        then false
+                        else (check_if_valid original_name some_sexpr)
+                |Pair(sexpr1, sexpr2) -> 
+                    (check_if_valid original_name sexpr1) &&
+                    (check_if_valid original_name sexpr2) 
+                |other -> true in
+
+            match e with
+            | TaggedSexpr(name, sexpr) -> let valid = check_if_valid name sexpr in
+            if valid then TaggedSexpr(name, sexpr) else raise X_this_should_not_happen
+            | other -> raise X_no_match ) in
+            nt s
+    and nt_comment_sexpr s =
+        let prefix = word "#;" in
+        let body = nt_sexpr in
+        let nt = caten prefix body in
+        (pack nt (fun e -> Nil)) 
+        s
+    and make_spaced_or_commented s = 
+        (* let nt_not_last_comment_sexpr = not_followed_by (pack nt_comment_sexpr (fun e -> Nil)) (pack (nt_end_of_input) (fun e -> Nil)) in *)
+        let whitespace_or_comment = disj_list [(pack nt_whitespace (fun e -> Nil));nt_comment_line;nt_comment_sexpr] in
+        let nt1 nt = make_paired (star whitespace_or_comment) (star whitespace_or_comment) nt in
+        nt1 s
+
+
+let read_sexpr string =
+  let (sexpr, s) = (nt_sexpr (string_to_list string)) in
+  if (s = [])
+  then sexpr
+  else raise X_no_match;;
+
+
+let read_sexprs string =
+    let (sexpr_list, s) = ((star nt_sexpr) (string_to_list string)) in
+    sexpr_list;;
+
+end;; (* struct Reader *)
+
+
diff --git a/readme.txt b/readme.txt
index e69de29..36530ca 100644
--- a/readme.txt
+++ b/readme.txt
@@ -0,0 +1,10 @@
+Tamar Rosen 312275845
+Ronen Krishtal 311303572
+
+We assert that the work we submitted is 100% our own. We have not received any
+part from any other student in the class, nor have we give parts of it for use to others.
+Nor have we used code from other sources: Courses taught previously at this university,
+courses taught at other universities, various bits of code found on the Internet, etc.
+We realize that should our code be found to contain code from other sources, that a
+formal case shall be opened against us with va’adat mishma’at, in pursuit of disciplinary
+action.
